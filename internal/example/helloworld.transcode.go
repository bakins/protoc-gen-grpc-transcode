// Code generated by protoc-gen-grpc-transcode. DO NOT EDIT.
// source: helloworld.proto

package helloworld

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	metadata "google.golang.org/grpc/metadata"
	status "google.golang.org/grpc/status"
	protojson "google.golang.org/protobuf/encoding/protojson"
	proto "google.golang.org/protobuf/proto"
	io "io"
	http "net/http"
	strings "strings"
)

type GreeterTranscode struct {
	client grpc.ClientConnInterface
}

func NewGreeterTranscode(client grpc.ClientConnInterface) *GreeterTranscode {
	handler := GreeterTranscode{
		client: client,
	}

	return &handler
}

func (t *GreeterTranscode) handleSayHello(ctx context.Context, input []byte) (proto.Message, metadata.MD, error) {
	var request HelloRequest
	if err := protojson.Unmarshal(input, &request); err != nil {
		grpcError := status.Errorf(codes.InvalidArgument, "failed to unmarshal request %s", err.Error())
		return nil, nil, grpcError
	}

	var headers metadata.MD
	var trailers metadata.MD
	var response HelloReply
	if err := t.client.Invoke(ctx, "/helloworld.Greeter/SayHello", &request, &response, grpc.Header(&headers), grpc.Trailer(&trailers)); err != nil {
		return nil, metadata.Join(headers, trailers), err
	}

	return &response, metadata.Join(headers, trailers), nil
}

func (t *GreeterTranscode) Methods() []string {
	return []string{
		"/helloworld.Greeter/SayHello",
	}
}

func (t *GreeterTranscode) sendError(w http.ResponseWriter, err error) {
	st, ok := status.FromError(err)
	if !ok {
		st = status.New(codes.Internal, err.Error())
	}

	w.Header().Set("Content-Type", "application/json")
	output, err := protojson.Marshal(st.Proto())
	if err != nil {
		output = []byte("{\"code\": 13, \"message\": \"there was an error but it could not be serialized into JSON\"}")
		w.WriteHeader(500)
		_, _ = w.Write(output)
	}

	switch st.Code() {
	case codes.Canceled:
		w.WriteHeader(499)
	case codes.Unknown:
		w.WriteHeader(500)
	case codes.InvalidArgument:
		w.WriteHeader(400)
	case codes.DeadlineExceeded:
		w.WriteHeader(504)
	case codes.NotFound:
		w.WriteHeader(404)
	case codes.AlreadyExists:
		w.WriteHeader(409)
	case codes.PermissionDenied:
		w.WriteHeader(403)
	case codes.ResourceExhausted:
		w.WriteHeader(429)
	case codes.FailedPrecondition:
		w.WriteHeader(400)
	case codes.Aborted:
		w.WriteHeader(409)
	case codes.OutOfRange:
		w.WriteHeader(400)
	case codes.Unimplemented:
		w.WriteHeader(501)
	case codes.Internal:
		w.WriteHeader(500)
	case codes.Unavailable:
		w.WriteHeader(503)
	case codes.DataLoss:
		w.WriteHeader(500)
	case codes.Unauthenticated:
		w.WriteHeader(401)
	default:
		w.WriteHeader(500)
	}

	w.Header().Set("Content-Type", "application/json")
	_, _ = w.Write(output)
}

func (t *GreeterTranscode) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "POST required", http.StatusMethodNotAllowed)
		return
	}

	if header := r.Header.Get("Content-Type"); header != "application/json" {
		i := strings.Index(header, ";")
		if i == -1 {
			i = len(header)
		}
		if strings.TrimSpace(strings.ToLower(header[:i])) != "application/json" {
			http.Error(w, "application/json required", http.StatusBadRequest)
			return
		}
	}

	var handler func(context.Context, []byte) (proto.Message, metadata.MD, error)

	switch r.URL.Path {
	case "/helloworld.Greeter/SayHello":
		handler = t.handleSayHello
	default:
		err := status.Errorf(codes.Unimplemented, "no handler for method %s", r.URL.Path)
		t.sendError(w, err)
		return
	}

	input, err := io.ReadAll(r.Body)
	if err != nil {
		grpcError := status.Errorf(codes.InvalidArgument, "failed to read request body %s", err.Error())
		t.sendError(w, grpcError)
		return
	}

	headers := metadata.MD{}
	for k, vv := range r.Header {
		key := strings.ToLower(k)
		switch key {
		case "content-type",
			"user-agent",
			"grpc-message-type",
			"grpc-encoding",
			"grpc-message",
			"grpc-status",
			"grpc-status-details-bin",
			"content-length",
			"accept-encoding",
			"connection",
			"proxy-connection",
			"keep-alive",
			"proxy-authenticate",
			"proxy-authorization",
			"te",
			"trailer",
			"transfer-Encoding",
			"upgrade",
			":authority":
		default:
			headers[key] = vv
		}
	}
	ctx := metadata.NewOutgoingContext(r.Context(), headers)

	response, md, err := handler(ctx, input)

	for k, vv := range md {
		for _, v := range vv {
			w.Header().Add(k, v)
		}
	}

	if err != nil {
		t.sendError(w, err)
		return
	}

	output, err := protojson.Marshal(response)
	if err != nil {
		grpcError := status.Errorf(codes.Internal, "failed to marshal response body %s", err.Error())
		t.sendError(w, grpcError)
		return
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	_, _ = w.Write(output)
}
