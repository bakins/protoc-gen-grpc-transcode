// Code generated by protoc-gen-grpc-transcode. DO NOT EDIT.
// source: helloworld.proto

package helloworld

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	protojson "google.golang.org/protobuf/encoding/protojson"
	proto "google.golang.org/protobuf/proto"
	io "io"
	http "net/http"
	strings "strings"
)

type GreeterTranscode struct {
	client grpc.ClientConnInterface
}

func NewGreeterTranscode(client grpc.ClientConnInterface) *GreeterTranscode {
	handler := GreeterTranscode{
		client: client,
	}

	return &handler
}

func (t *GreeterTranscode) handleSayHello(ctx context.Context, input []byte) (proto.Message, error) {
	var request HelloRequest
	if err := protojson.Unmarshal(input, &request); err != nil {
		grpcError := status.Errorf(codes.InvalidArgument, "failed to unmarshal request %s", err.Error())
		return nil, grpcError
	}

	var response HelloReply
	if err := t.client.Invoke(ctx, "/helloworld.Greeter/SayHello", &request, &response); err != nil {
		return nil, err
	}

	return &response, nil
}

func (t *GreeterTranscode) Methods() []string {
	return []string{
		"/helloworld.Greeter/SayHello",
	}
}

func (t *GreeterTranscode) sendError(w http.ResponseWriter, err error) {
	st, ok := status.FromError(err)
	if !ok {
		st = status.New(codes.Internal, err.Error())
	}

	w.Header().Set("Content-Type", "application/json")
	output, err := protojson.Marshal(st.Proto())
	if err != nil {
		output = []byte("{\"code\": 13, \"message\": \"there was an error but it could not be serialized into JSON\"}")
		w.WriteHeader(500)
		_, _ = w.Write(output)
	}

	switch st.Code() {
	case codes.Canceled:
		w.WriteHeader(499)
	case codes.Unknown:
		w.WriteHeader(500)
	case codes.InvalidArgument:
		w.WriteHeader(400)
	case codes.DeadlineExceeded:
		w.WriteHeader(504)
	case codes.NotFound:
		w.WriteHeader(404)
	case codes.AlreadyExists:
		w.WriteHeader(409)
	case codes.PermissionDenied:
		w.WriteHeader(403)
	case codes.ResourceExhausted:
		w.WriteHeader(429)
	case codes.FailedPrecondition:
		w.WriteHeader(400)
	case codes.Aborted:
		w.WriteHeader(409)
	case codes.OutOfRange:
		w.WriteHeader(400)
	case codes.Unimplemented:
		w.WriteHeader(501)
	case codes.Internal:
		w.WriteHeader(500)
	case codes.Unavailable:
		w.WriteHeader(503)
	case codes.DataLoss:
		w.WriteHeader(500)
	case codes.Unauthenticated:
		w.WriteHeader(401)
	default:
		w.WriteHeader(500)
	}

	w.Header().Set("Content-Type", "application/json")
	_, _ = w.Write(output)
}

func (t *GreeterTranscode) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "POST required", http.StatusMethodNotAllowed)
		return
	}

	header := r.Header.Get("Content-Type")
	if header != "application/json" {
		i := strings.Index(header, ";")
		if i == -1 {
			i = len(header)
		}
		if strings.TrimSpace(strings.ToLower(header[:i])) != "application/json" {
			http.Error(w, "application/json required", http.StatusBadRequest)
			return
		}
	}

	var handler func(context.Context, []byte) (proto.Message, error)

	switch r.URL.Path {
	case "/helloworld.Greeter/SayHello":
		handler = t.handleSayHello
	default:
		err := status.Errorf(codes.Unimplemented, "no handler for method %s", r.URL.Path)
		t.sendError(w, err)
		return
	}

	input, err := io.ReadAll(r.Body)
	if err != nil {
		grpcError := status.Errorf(codes.InvalidArgument, "failed to read request body %s", err.Error())
		t.sendError(w, grpcError)
		return
	}

	response, err := handler(r.Context(), input)
	if err != nil {
		t.sendError(w, err)
		return
	}

	output, err := protojson.Marshal(response)
	if err != nil {
		grpcError := status.Errorf(codes.Internal, "failed to marshal response body %s", err.Error())
		t.sendError(w, grpcError)
		return
	}
	w.Header().Set("Content-Type", "application/json")
	_, _ = w.Write(output)
}
