package main

import (
	"flag"

	"google.golang.org/protobuf/compiler/protogen"
)

func main() {
	var flags flag.FlagSet

	protogen.Options{
		ParamFunc: flags.Set,
	}.Run(func(gen *protogen.Plugin) error {
		for _, f := range gen.Files {
			if f.Generate {
				if _, err := generateFile(gen, f); err != nil {
					return err
				}
			}
		}
		return nil
	})
}

func generateFile(gen *protogen.Plugin, file *protogen.File) (*protogen.GeneratedFile, error) {
	if len(file.Services) == 0 {
		return nil, nil
	}

	filename := file.GeneratedFilenamePrefix + ".transcode.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	g.P("// Code generated by protoc-gen-grpc-transcode. DO NOT EDIT.")
	g.P("// source: ", file.Desc.Path())
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	if err := generateFileContent(gen, file, g); err != nil {
		return nil, err
	}

	return g, nil
}

func generateFileContent(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile) error {
	for _, service := range file.Services {
		if err := genService(gen, file, g, service); err != nil {
			return err
		}
	}

	return nil
}

const (
	contextPackage   = protogen.GoImportPath("context")
	httpPackage      = protogen.GoImportPath("net/http")
	bytesPackage     = protogen.GoImportPath("bytes")
	ioPackage        = protogen.GoImportPath("io")
	protoPackage     = protogen.GoImportPath("google.golang.org/protobuf/proto")
	statusPackage    = protogen.GoImportPath("google.golang.org/grpc/status")
	codesPackage     = protogen.GoImportPath("google.golang.org/grpc/codes")
	protojsonPackage = protogen.GoImportPath("google.golang.org/protobuf/encoding/protojson")
	grpcPackage      = protogen.GoImportPath("google.golang.org/grpc")
	stringsPackage   = protogen.GoImportPath("strings")
)

func genService(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, service *protogen.Service) error {
	transcodeName := service.GoName + "Transcode"

	g.P("type ", transcodeName, " struct {")
	g.P(`    client `, grpcPackage.Ident("ClientConnInterface"))
	g.P("}")
	g.P()

	g.P(`func New`, transcodeName,
		`(client `, grpcPackage.Ident("ClientConnInterface"), `) *`, transcodeName, `{`)
	g.P(`    handler := `, transcodeName, `{`)
	g.P(`        client: client,`)
	g.P(`    }`)
	g.P()
	g.P("    return &handler")
	g.P("}")
	g.P()

	for _, method := range service.Methods {
		// pass through headers?
		g.P(` func (t *`, transcodeName, `)handle`, method.Desc.Name(), `(ctx `,
			contextPackage.Ident("Context"), `, input []byte) (`, protoPackage.Ident("Message"), `, error) {`)
		g.P(`    var request `, method.Input.GoIdent)
		g.P(`    if err := `, protojsonPackage.Ident("Unmarshal"), `(input, &request); err != nil {`)
		g.P(`        grpcError := `, statusPackage.Ident("Errorf"),
			`(`, codesPackage.Ident("InvalidArgument"), `, "failed to unmarshal request %s", err.Error())`)
		g.P(`        return nil, grpcError`)
		g.P(`    }`)
		g.P()
		g.P(`    var response `, method.Output.GoIdent)
		g.P(`    if err := t.client.Invoke(ctx, "/`,
			service.Desc.FullName(), `/`, method.Desc.Name(),
			`", &request, &response); err != nil {`)
		g.P(`         return nil, err`)
		g.P(`    }`)
		g.P()
		g.P(`    return &response, nil`)
		g.P(`}`)
		g.P()
	}

	g.P(`func (t *`, transcodeName, `)Methods() []string {`)
	g.P(`    return []string{`)
	for _, method := range service.Methods {
		g.P(`        "/`, service.Desc.FullName(), `/`, method.Desc.Name(), `",`)
	}
	g.P(`    }`)
	g.P(`}`)
	g.P()

	g.P("func (t *", transcodeName, ")sendError(w ",
		httpPackage.Ident("ResponseWriter"), ", err error) {")
	g.P(`    st, ok := `, statusPackage.Ident("FromError"), `(err)`)
	g.P(`    if !ok {`)
	g.P(`      st = `, statusPackage.Ident("New"), `(`, codesPackage.Ident("Internal"), `, err.Error())`)
	g.P(`    }`)
	g.P()
	g.P(`    w.Header().Set("Content-Type", "application/json")`)
	g.P(`    output, err := `, protojsonPackage.Ident("Marshal"), `(st.Proto())`)
	g.P(`    if err != nil {`)
	g.P(`        output = []byte("{\"code\": 13, \"message\": \"there was an error but it could not be serialized into JSON\"}")`)
	g.P(`        w.WriteHeader(500)`)
	g.P(`   	 _, _ = w.Write(output)`)
	g.P(`    }`)
	g.P()
	// based on https://github.com/envoyproxy/envoy/blob/0fae6970ddaf93f024908ba304bbd2b34e997a51/source/common/grpc/status.cc#L28
	// and https://cloud.google.com/apis/design/errors#handling_errors
	g.P(`    switch st.Code() {`)
	g.P(`    case `, codesPackage.Ident("Canceled"), `:`)
	g.P(`        w.WriteHeader(499)`)
	g.P(`    case `, codesPackage.Ident("Unknown"), `:`)
	g.P(`        w.WriteHeader(500)`)
	g.P(`    case `, codesPackage.Ident("InvalidArgument"), `:`)
	g.P(`        w.WriteHeader(400)`)
	g.P(`    case `, codesPackage.Ident("DeadlineExceeded"), `:`)
	g.P(`        w.WriteHeader(504)`)
	g.P(`    case `, codesPackage.Ident("NotFound"), `:`)
	g.P(`        w.WriteHeader(404)`)
	g.P(`    case `, codesPackage.Ident("AlreadyExists"), `:`)
	g.P(`        w.WriteHeader(409)`)
	g.P(`    case `, codesPackage.Ident("PermissionDenied"), `:`)
	g.P(`        w.WriteHeader(403)`)
	g.P(`    case `, codesPackage.Ident("ResourceExhausted"), `:`)
	g.P(`        w.WriteHeader(429)`)
	g.P(`    case `, codesPackage.Ident("FailedPrecondition"), `:`)
	g.P(`        w.WriteHeader(400)`)
	g.P(`    case `, codesPackage.Ident("Aborted"), `:`)
	g.P(`        w.WriteHeader(409)`)
	g.P(`    case `, codesPackage.Ident("OutOfRange"), `:`)
	g.P(`        w.WriteHeader(400)`)
	g.P(`    case `, codesPackage.Ident("Unimplemented"), `:`)
	g.P(`        w.WriteHeader(501)`)
	g.P(`    case `, codesPackage.Ident("Internal"), `:`)
	g.P(`        w.WriteHeader(500)`)
	g.P(`    case `, codesPackage.Ident("Unavailable"), `:`)
	g.P(`        w.WriteHeader(503)`)
	g.P(`    case `, codesPackage.Ident("DataLoss"), `:`)
	g.P(`        w.WriteHeader(500)`)
	g.P(`    case `, codesPackage.Ident("Unauthenticated"), `:`)
	g.P(`        w.WriteHeader(401)`)
	g.P(`    default :`)
	g.P(`        w.WriteHeader(500)`)
	g.P(`    }`)
	g.P()
	g.P(`    w.Header().Set("Content-Type", "application/json")`)
	g.P(`    _, _ = w.Write(output)`)
	g.P(`}`)
	g.P()

	g.P(`func (t *`, transcodeName, `)ServeHTTP(w `,
		httpPackage.Ident("ResponseWriter"), `, `,
		`r *`, httpPackage.Ident("Request"),
		`){`)
	g.P(`    if r.Method != `, httpPackage.Ident("MethodPost"), `{`)
	g.P(`        `, httpPackage.Ident("Error"), `(w, "POST required", `, httpPackage.Ident("StatusMethodNotAllowed"), `)`)
	g.P(`        return`)
	g.P(`    }`)
	g.P()
	g.P(`    header := r.Header.Get("Content-Type")`)
	g.P(`    if header != "application/json" {`)
	g.P(`        i := `, stringsPackage.Ident("Index"), `(header, ";")`)
	g.P(`        if i == -1 {`)
	g.P(`    	    i = len(header)`)
	g.P(`        }`)
	g.P(`        if `, stringsPackage.Ident("TrimSpace"), `(`, stringsPackage.Ident("ToLower"), `(header[:i])) != "application/json" {`)
	g.P(`            `, httpPackage.Ident("Error"), `(w, "application/json required", `, httpPackage.Ident("StatusBadRequest"), `)`)
	g.P(`            return`)
	g.P(`        }`)
	g.P(`    }`)
	g.P()
	g.P(`    var handler func(context.Context, []byte) (proto.Message, error)`)
	g.P()
	g.P(`    switch r.URL.Path {`)
	for _, method := range service.Methods {
		g.P(`        case "/`, service.Desc.FullName(), `/`, method.Desc.Name(), `":`)
		g.P(`            handler = t.handle`, method.Desc.Name())
	}
	g.P(`        default:`)
	g.P(`            err := `, statusPackage.Ident("Errorf"), `(`,
		codesPackage.Ident("Unimplemented"),
		`, "no handler for method %s", r.URL.Path`,
		`)`,
	)
	g.P(`            t.sendError(w, err)`)
	g.P(`            return`)
	g.P(`    }`)
	g.P()
	g.P(`    input, err := `, ioPackage.Ident("ReadAll"), "(r.Body)")
	g.P(`    if err != nil {`)
	g.P(`            grpcError := `, statusPackage.Ident("Errorf"), `(`,
		codesPackage.Ident("InvalidArgument"),
		`, "failed to read request body %s", err.Error()`,
		`)`)
	g.P(`            t.sendError(w, grpcError)`)
	g.P(`            return`)
	g.P(`    }`)
	g.P()
	g.P(`    response, err := handler(r.Context(), input)`)
	g.P(`    if err != nil {`)
	g.P(`        t.sendError(w, err)`)
	g.P(`        return`)
	g.P(`    }`)
	g.P()
	g.P(`    output, err := `, protojsonPackage.Ident("Marshal"), `(response)`)
	g.P(`    if err != nil {`)
	g.P(`            grpcError := `, statusPackage.Ident("Errorf"), `(`,
		codesPackage.Ident("Internal"),
		`, "failed to marshal response body %s", err.Error()`,
		`)`)
	g.P(`            t.sendError(w, grpcError)`)
	g.P(`            return`)
	g.P(`    }`)
	g.P(`    w.Header().Set("Content-Type", "application/json")`)
	g.P(`    _, _ = w.Write(output)`)
	g.P(`}`)
	g.P()

	return nil
}
